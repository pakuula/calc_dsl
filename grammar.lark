// Grammar for the math DSL.

?start: statement_list?

?statement_list: SEP* (statement (SEP+ statement)*)? SEP*

?statement: assignment
          | break_stmt
          | next_stmt
          | expr

assignment: NAME assign_op expr
assign_op: ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | DIV_ASSIGN | MOD_ASSIGN

?expr: for_expr
     | block
     | print_call
     | conditional_expr

conditional_expr: or_expr
                | or_expr "if" or_expr "else" SEP* conditional_expr

?or_expr: and_expr (OR and_expr)*

?and_expr: not_expr (AND not_expr)*

?not_expr: NOT not_expr
         | comparison

?comparison: sum ((COMP_OP) sum)*

?sum: product ((PLUS | MINUS) product)*
?product: power ((STAR | SLASH | MOD) power)*
?power: unary (POW power)?
?unary: (PLUS | MINUS) unary
      | atom

?atom: NUMBER           -> number
     | func_call
     | NAME             -> var
     | "(" conditional_expr ")"

func_call: NAME "(" arg_list? ")"
arg_list: expr ("," expr)*

for_expr: "for" NAME "in" expr ".." expr ("by" expr)? block

block: "(" statement_list? ")"

print_call: "print" "(" print_args? ")"
print_args: print_arg ("," print_arg)*
print_arg: STRING | expr

break_stmt: "break" from_clause? when_clause? "with" expr
next_stmt: "next" loop_var? when_clause?

from_clause: "from" NAME
when_clause: "when" expr
loop_var: NAME

COMP_OP: "==" | "!=" | "<" | "<=" | ">" | ">="

OR: "or"
AND: "and"
NOT: "not"

ASSIGN: "="
PLUS_ASSIGN: "+="
MINUS_ASSIGN: "-="
DIV_ASSIGN: "/="
MOD_ASSIGN: "mod="

PLUS: "+"
MINUS: "-"
STAR: "*"
SLASH: "/"
POW: "**"
MOD: "mod"

%import common.CNAME -> NAME
NUMBER: /(\d+(\.\d+)?|\.\d+)/
%import common.ESCAPED_STRING -> STRING

SEP: /;|\n+/

%ignore /[ \t\f\r]+/
%ignore /#[^\n]*/
