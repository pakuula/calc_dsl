# Спецификация DSL для скрипта-калькулятора

## Цели

Язык предназначен для вычисления математических выражений, ведения вычислений с переменными и выполнения простых циклов. Программа состоит из statements, которые могут разделяться новой строкой или `;`.

## Математическая модель

- Числа: `decimal` или float произвольной точности. Конкретный тип выбирается на этапе реализации.
- Константы: `pi`, `e`.
- Операторы: `+`, `-`, `*`, `/`, `**`, `mod`.
- `mod` равноприоритетен `*` и `/` и левоассоциативен.
- Для выражения вида `a ** b mod p` применяется модульная степень.
- Семантика `mod` для отрицательных чисел: результат всегда в диапазоне `[0, |p|)`, если `p != 0`. Например:
  - `-5 mod 3 == 1`.
  - `5 mod -3 == 2` (модуль по абсолютному делителю).
- Остаток от деления всегда неотрицательный (математическая семантика).

## Функции

Встроенные функции:

- `ln(x)`, `log2(x)`, `log10(x)`, `sin(x)`, `cos(x)`, `tg(x)`, `ctg(x)`, `sqrt(x)`, `nrt(x, n)`.
- `nrt(x, n)` вычисляет $x^{1/n}$. Для четного `n` и отрицательного `x` бросается ошибка домена.

## Точность вычислений

- В языке есть функции `set_precision(N)` и `get_precision()`.
- При запуске интерпретатора точность равна 10.
- `set_precision(N)` принимает целое `N > 0`.
- Точность влияет на вывод чисел и вычисления функций: результат округляется до `N` знаков после запятой (механизм округления зависит от выбранного числового типа).

## Присваивания

- Обычное: `x = 10`.
- Сокращенные: `+=`, `-=`, `/=`, `mod=`.
- Одно присваивание на один statement.
- Присваивание — это statement без значения. Его нельзя использовать как выражение.

## Условные выражения

### Операторы сравнения

- `==` — равенство.
- `!=` — неравенство.
- `<` — строго меньше.
- `<=` — меньше или равно.
- `>` — строго больше.
- `>=` — больше или равно.
- Результат: булевское значение (true или false).
- Пример: `x > 10` — возвращает true, если `x` больше 10.

### Логические операторы

- `not expr` — логическое отрицание. Возвращает true, если `expr` ложно.
  - Пример: `not (i mod 2 == 0)` — true для нечетных чисел.

- `expr1 and expr2` — логическое И (конъюнкция). Возвращает true, если оба выражения истинны. Использует short-circuit оценку (вычисляет `expr2` только если `expr1` истинно).
  - Пример: `i > 0 and i < 10` — true, если i находится в диапазоне от 1 до 9.

- `expr1 or expr2` — логическое ИЛИ (дизъюнкция). Возвращает true, если хотя бы одно выражение истинно. Использует short-circuit оценку (вычисляет `expr2` только если `expr1` ложно).
  - Пример: `i mod 5 == 0 or i mod 7 == 0` — true, если i кратно 5 или 7.

### Условное выражение if-else

- Синтаксис: `expr1 if condition else expr2`.
- Семантика: если `condition` истинно, вычисляется и возвращается `expr1`, иначе вычисляется и возвращается `expr2`.
- Условное выражение может использоваться везде, где ожидается выражение (в присваиваниях, циклах, функциях, операндах операций и т.д.).
- Пример: `x = 10 if i > 5 else 20` — присвоить `x` значение 10, если `i > 5`, иначе 20.
- Пример: `for i in 1 .. 10 (sum += i if i mod 2 == 0 else 0)` — добавить только четные числа.

### Приоритеты операторов (от высшего к низшему)

1. Сравнение: `==`, `!=`, `<`, `<=`, `>`, `>=`
2. `not`
3. `and`
4. `or`
5. `if-else`

- Пример: `a > b and not c or d` эквивалентно `((a > b) and (not c)) or d`.
- Пример: `x if a and b else y` эквивалентно `x if (a and b) else y`.

### Ограничения

- Булевские значения (результаты сравнений и логических операторов) нельзя присваивать переменным или использовать в арифметических операциях.
- Пример: `x = a > b` — **ошибка**.
- Пример: `x = (a > b) + 10` — **ошибка**.
- Булевские значения можно использовать только как условия в `if-else` и в логических операторах.

## Ввод/вывод

- Функция `print(x, y, z, ...)` выводит значения, разделенные пробелом.
- Строковые литералы разрешены только внутри `print`.

## Блоки и циклы

- Блок: `( statements )`.
- В блоке statement разделяются новой строкой или `;`.
- Результат блока — результат последнего statement.
- Цикл: `for var in start..end [by step] (statements)`.
- Диапазон включает `end`. `step` по умолчанию равен 1.
- Результат цикла — результат последнего statement последней итерации.
- Цикл можно использовать как выражение, например: `x = for i in 1..3 (i)`.
- Цикл по возрастающей: выполняется, пока `i <= end`, затем `i += step`, где `step > 0`.
- Цикл по убывающей: выполняется, пока `i >= end`, затем `i += step`, где `step < 0`.
- Переменную цикла можно изменять внутри цикла.
- После цикла переменная цикла видна только если она была определена до начала цикла. В этом случае она сохраняет последнее корректное значение. Если цикл не выполнился ни разу, переменная не изменяется.

### Управление потоком выполнения: break и next

- **break**: `break [from var] [when condition] with result_expr` — выход из цикла с указанным результатом.
  - `from var` — опционально, переменная цикла для выхода. Если не указано, выход из ближайшего (текущего) цикла.
  - `when condition` — опционально, условие выхода. Если условие ложно, break игнорируется.
  - `with result_expr` — обязательно, значение для возврата из цикла. Это значение становится результатом цикла.
  - Пример: `break when i > 50 with i * 2` — выход из цикла, если `i > 50`, с результатом `i * 2`.
  
- **next**: `next [var] [when condition]` — переход к следующей итерации цикла.
  - `var` — опционально, переменная цикла. Если не указано, переход к следующей итерации ближайшего цикла.
  - `when condition` — опционально, условие для next. Если условие ложно, next игнорируется.
  - Пример: `next when i mod 2 == 0` — пропустить остаток итерации, если `i` четное.

- **Семантика результата цикла с break/next**:
  - Если break выполнился — результат цикла равен значению из `with`.
  - Если break не выполнился ни разу — результат цикла остается обычным (результат последнего statement последней итерации).
  - Если были итерации с next — результат цикла равен результату последней выполненной итерации.

- **Ошибки**:
  - `break` или `next` вне цикла выбрасывает ошибку.
  - `break from var` или `next var` из несуществующего цикла выбрасывает ошибку.
  - Вложенные циклы с одинаковой переменной выбрасывают ошибку.

## Комментарии

- Все, что идет после `#` до конца строки, игнорируется.

## Ошибки

- Ошибки представлены исключениями. Базовый тип: `DSLError`.
- Деление на ноль: `DivisionByZeroError`.
- Неизвестная переменная: `VariableNotFoundError`.
- Доменная ошибка для функций (например, `sqrt(-1)`): `DSLError` с указанием причины.
- Любая ошибка должна включать строку и позицию в тексте исходной программы.

## Пользовательские истории

- Как пользователь, я хочу писать `x = 5; x += 10; x mod= 4` и получить `3`.
- Как пользователь, я хочу писать `2 + 2 * 2` и получать `6`.
- Как пользователь, я хочу писать `2 ** 3 mod 5` и получать `3`.
- Как пользователь, я хочу `print("x =", x)` и видеть строку и число, разделенные пробелом.
- Как пользователь, я хочу выполнять цикл `for i in 1..3 (sum += i)` и получить сумму 6.
- Как пользователь, я хочу присвоить результат цикла: `fib = for i in 2..n (curr)`.
- Как пользователь, я хочу явно управлять точностью через `set_precision(5)` и читать текущую точность через `get_precision()`.
