# Спецификация DSL для скрипта-калькулятора

## Цели
Язык предназначен для вычисления математических выражений, ведения вычислений с переменными и выполнения простых циклов. Программа состоит из statements, которые могут разделяться новой строкой или `;`.

## Математическая модель
- Числа: `decimal` или float произвольной точности. Конкретный тип выбирается на этапе реализации.
- Константы: `pi`, `e`.
- Операторы: `+`, `-`, `*`, `/`, `**`, `mod`.
- `mod` равноприоритетен `*` и `/` и левоассоциативен.
- Для выражения вида `a ** b mod p` применяется модульная степень.
- Семантика `mod` для отрицательных чисел: результат всегда в диапазоне `[0, |p|)`, если `p != 0`. Например:
  - `-5 mod 3 == 1`.
  - `5 mod -3 == 2` (модуль по абсолютному делителю).
- Остаток от деления всегда неотрицательный (математическая семантика).

## Функции
Встроенные функции:
- `ln(x)`, `log2(x)`, `log10(x)`, `sin(x)`, `cos(x)`, `tg(x)`, `ctg(x)`, `sqrt(x)`, `nrt(x, n)`.
- `nrt(x, n)` вычисляет $x^{1/n}$. Для четного `n` и отрицательного `x` бросается ошибка домена.

## Точность вычислений
- В языке есть функции `set_precision(N)` и `get_precision()`.
- При запуске интерпретатора точность равна 10.
- `set_precision(N)` принимает целое `N > 0`.
- Точность влияет на вывод чисел и вычисления функций: результат округляется до `N` знаков после запятой (механизм округления зависит от выбранного числового типа).

## Присваивания
- Обычное: `x = 10`.
- Сокращенные: `+=`, `-=`, `/=`, `mod=`.
- Одно присваивание на один statement.
- Присваивание — это statement без значения. Его нельзя использовать как выражение.

## Ввод/вывод
- Функция `print(x, y, z, ...)` выводит значения, разделенные пробелом.
- Строковые литералы разрешены только внутри `print`.

## Блоки и циклы
- Блок: `( statements )`.
- В блоке statement разделяются новой строкой или `;`.
- Результат блока — результат последнего statement.
- Цикл: `for var in start..end [by step] (statements)`.
- Диапазон включает `end`. `step` по умолчанию равен 1.
- Результат цикла — результат последнего statement последней итерации.
- Цикл можно использовать как выражение, например: `x = for i in 1..3 (i)`.
- Цикл по возрастающей: выполняется, пока `i <= end`, затем `i += step`, где `step > 0`.
- Цикл по убывающей: выполняется, пока `i >= end`, затем `i += step`, где `step < 0`.
- Переменную цикла можно изменять внутри цикла.
- После цикла переменная цикла видна только если она была определена до начала цикла. В этом случае она сохраняет последнее корректное значение. Если цикл не выполнился ни разу, переменная не изменяется.

## Комментарии
- Все, что идет после `#` до конца строки, игнорируется.

## Ошибки
- Ошибки представлены исключениями. Базовый тип: `DSLError`.
- Деление на ноль: `DivisionByZeroError`.
- Неизвестная переменная: `VariableNotFoundError`.
- Доменная ошибка для функций (например, `sqrt(-1)`): `DSLError` с указанием причины.
- Любая ошибка должна включать строку и позицию в тексте исходной программы.

## Пользовательские истории
- Как пользователь, я хочу писать `x = 5; x += 10; x mod= 4` и получить `3`.
- Как пользователь, я хочу писать `2 + 2 * 2` и получать `6`.
- Как пользователь, я хочу писать `2 ** 3 mod 5` и получать `3`.
- Как пользователь, я хочу `print("x =", x)` и видеть строку и число, разделенные пробелом.
- Как пользователь, я хочу выполнять цикл `for i in 1..3 (sum += i)` и получить сумму 6.
- Как пользователь, я хочу присвоить результат цикла: `fib = for i in 2..n (curr)`.
- Как пользователь, я хочу явно управлять точностью через `set_precision(5)` и читать текущую точность через `get_precision()`.
